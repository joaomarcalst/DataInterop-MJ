\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc} %Suporte para caracteres UTF-8
\usepackage{geometry} %Para ajustes de margem e formato da página
\usepackage{fancyhdr} %Para cabeçalhos e rodapés
\usepackage{enumerate}
\usepackage{enumitem} %Pacote para personalizar listas
\usepackage{ragged2e} %Pacote para justificação
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{soul}
\usepackage{float}

%Dimensões da Página
\geometry{
    a4paper,
    left=2cm,
    right=2cm,
    top=2.5cm,
    bottom=2.5cm
}

%Configurando o Cabeçalho
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Exam 01 - Data Interoperability and Semantics}
\fancyfoot[R]{\thepage}

% Configuração de estilo de código com o pacote listings
\lstset{
    basicstyle=\ttfamily\small, % Fonte monoespaçada pequena
    breaklines=true, % Quebra linhas longas
    columns=flexible, % Ajuste flexível das colunas
    frame=none, % Adiciona uma moldura ao redor do código
    captionpos=b % Legenda na parte inferior
}

% Definindo um estilo básico para o código ASN.1
\lstdefinelanguage{ASN.1}{
  morekeywords={BEGIN, END, SEQUENCE, INTEGER, BOOLEAN, OPTIONAL, DEFAULT, CHOICE, ENUMERATED, OF},
  sensitive=false,
  morecomment=[l]--,  % Comentários começam com --
  morestring=[b]",    % Strings são delimitadas por "
}

% Configuração de estilo para JSON
\lstdefinelanguage{json}{
    basicstyle=\ttfamily\small, % Fonte monoespaçada
    showstringspaces=false,
    breaklines=true, % Quebra automática de linhas
    stringstyle=\color{blue}, % Cor para strings
    commentstyle=\color{gray}, % Cor para comentários
    keywordstyle=\color{green}, % Cor para palavras-chave
    morestring=[b]", % Strings são delimitadas por aspas duplas
    morecomment=[l]{//}, % Comentários com //
}

%Começo do Documento
\begin{document}

\begin{flushleft}
    \textbf{Student:} João Pedro Marçal Storino (B2) \\
    \textbf{Teacher:} Maxime Lefrançois \\
    \textbf{Majeur:} Informatique \\
    \textbf{Subject:} Data Interoperability and Semantics \\
    \textbf{Date:} 22/10/2024 \\
\end{flushleft}

%Título do Documento
\vspace{0cm}
\begin{center}
    {\LARGE \textbf{Exam 01}}
\end{center}
\vspace{-.5cm}

\begin{enumerate}[label=\textbf{Part \arabic*}]
    \item - \textbf{(5 points)} Comparison of main data formats.
\end{enumerate}

On one large full-page table, shortly describe or compare each data formats from List 1 in terms of the features and
criteria from List 2.

\textbf{NOTE: Be concise. You don’t need to justify.}


\begin{enumerate}[label=\textbf{List \arabic*.}]
    \item \textbf{Data Formats:}

    % Ajustar para garantir que a tabela seja alinhada corretamente
    \noindent\resizebox{\textwidth}{!}{
    \begin{tabularx}{\textwidth}{XXXX}
        \text{1. CSV} & \text{2. JSON} & \text{3. XML} & \text{4. YAML}
    \end{tabularx}
    }
    \item \textbf{Features and Criteria}
    \begin{enumerate}[label=\text{\arabic*.}]
        \item \textbf{Simplicity:} How easy is the format to create, read, and modify by both humans and machines?
        \item \textbf{Human-Readability:} Can the data be easily understood and edited in a text editor or similar tool?
        \item \textbf{Interoperability:} Is the format widely supported across different tools, software, and platforms?
        \item \textbf{File Size/Overhead:} How lightweight is the format in terms of file size, especially for large datasets?
        \item \textbf{Metadata Support:} Does the format allow embedding of metadata (e.g., column types, descriptions, units) within the file?
        \item \textbf{Structural Complexity:} Can the format handle complex data structures, such as nested, hierarchical, relational, or graph data?
        \item \textbf{Query:} Are there dedicated query language for the format?
        \item \textbf{Schema Validation:} Does the format support a schema or mechanism to enforce data consistency and integrity?
        \item \textbf{Extensibility:} Can the format be extended with custom structures or elements without breaking compatibility (e.g., custom tags or schemas)?
        \item Can the format be extended with custom structures or elements without breaking compatibility (e.g., custom tags or schemas)?
    \end{enumerate}
\end{enumerate}

%Separador Horizontal
\noindent\rule{\textwidth}{0.4mm} 

\textbf{Answer:}

\[
\begin{array}{|c|c|c|c|c|}
    \hline
    \textbf{\large Features/Criteria} & \textbf{\large CSV} & \textbf{\large JSON} & \textbf{\large XML} & \textbf{\large YAML} \\
    \hline
    \multicolumn{1}{|l|}{\text{1. Simplicity}} & + & = & - & + \\
    \hline
    \multicolumn{1}{|l|}{\text{2. Human-Readability}} & + & = & - & + \\
    \hline
    \multicolumn{1}{|l|}{\text{3. Interoperability}} & + & + & + & = \\
    \hline
    \multicolumn{1}{|l|}{\text{4. File Size/Overhead}} & + & = & - & + \\
    \hline
    \multicolumn{1}{|l|}{\text{5. Data Type Support}} & - & + & + & + \\
    \hline
    \multicolumn{1}{|l|}{\text{6. Metadata Support}} & - & = & + & = \\
    \hline
    \multicolumn{1}{|l|}{\text{7. Structural Complexity}} & - & + & + & + \\
    \hline
    \multicolumn{1}{|l|}{\text{8. Query}} & - & = & + & - \\
    \hline
    \multicolumn{1}{|l|}{\text{9. Schema Validation}} & - & = & + & = \\
    \hline
    \multicolumn{1}{|l|}{\text{10. Extensibility}} & - & + & + & + \\
    \hline
\end{array}
\]

\break

\begin{enumerate}[label=\textbf{Part \arabic*.}]
    \setcounter{enumi}{1}
    \item \textbf{(/20 points)} ASN.1
\end{enumerate}

ASN.1 is a standard interface description language for defining data structures that can be serialized and deserialized
in a cross-platform way. It provides a formal way to describe data and enables interoperability across different
systems by ensuring consistent data encoding and decoding. While ASN.1 is now 40 years old, it is still broadly used
in telecommunication and computer networking, such as for 5G mobile phone communications, LDAP directories,
Securing HTTP communications with TLS (X.509) Certificates, Intelligent Transport Systems, and the Interledger
Protocol for digital payments.

Protocol developers define data structures in ASN.1 modules, which are generally a section of a broader standards
document written in the ASN.1 language. Here are some common ASN.1 base data types:

\begin{list}{}{ % Aqui definimos os marcadores
    \setlength{\leftmargin}{0.5cm} % Recuo da margem esquerda
    \setlength{\itemsep}{0cm} % Espaçamento entre os itens
}
    \item BOOLEAN [tag number 0110]: value can be TRUE or FALSE 
    \item INTEGER [tag: 0210]: a signed integer. A valid range can be specified with the notation (min..max)
    \item BIT STRING [tag number 0310]: used for bit arrays, where each bit has an individual meaning.
    \item ENUMERATED [tag number 1010]: a list of named items.
    \item SEQUENCE [tag number 1610]: a collection of items to group together.
    \item CHOICE [n/a]: one of the items can be present at a time.
    \item IA5String [tag number 2210]: a printable ASCII string.
\end{list}

Below is an ASN.1 module definition, adapted from the ETSI Intelligent Transport Systems (ITS) Common Data Dictionary definition. You can find more details at the following link: \url{https://forge.etsi.org/rep/ITS/asn1/cdd_ts102894_2}.

\textbf{Note:} “\texttt{ego}” is how we name the vehicle on which the communicating ITS system is deployed. “\texttt{alter}” is another vehicle that is observed by “\texttt{ego}”, or that communicates with “\texttt{ego}”.

\begin{multicols}{2}
    \begin{lstlisting}[language=ASN.1]
        ETSI-ITS-CDD DEFINITIONS AUTOMATIC TAGS
        ::= BEGIN
        EgoData ::=SEQUENCE { --invented for the Exam --
            id              IA5String,
            energyStorage   EnergyStorageType,
            speed           SpeedValue,
            driveDirection  DriveDirection,
            lanePosition    LanePositionOptions
        }
        AlterData ::= SEQUENCE { -- invented --
            id              IA5String OPTIONAL,
            message         IA5String OPTIONAL,
            safeDistance    SafeDistanceIndicator,
            speed           SpeedValue,
            driveDirection  DriveDirection,
            lanePosition    LanePositionOptions
        }
        EnergyStorageType ::= BIT STRING { -- real def --
            hydrogenStorage         (0),
            electricEnergyStorage   (1),
            liquidPropaneGas        (2),
            compressedNaturalGas    (3),
            diesel                  (4),
            gasoline                (5),
            ammonia                 (6)
        }(SIZE(7))
        SafeDistanceIndicator::= BOOLEAN -- real def --
        SpeedValue ::= INTEGER { -- unit is 0,01 m/s --
            standstill      (0),
            outOfRange      (16382),
            unavailable     (16383)
        } (0..16383)
    \end{lstlisting}

    \vfill % Espaço vertical para ajustar o conteúdo

    \begin{lstlisting}[language=ASN.1]
        DriveDirection ::= ENUMERATED { -- real def --
            forward     (0),
            backward    (1),
            unavailable (2)
        }
        LanePositionOptions ::= CHOICE { -- real def --
            simplelanePosition LanePosition,
            simpleLaneType LaneType,
            detailedlanePosition LanePositionAndType,
            ...
        }
        LanePositionAndType::= SEQUENCE { -- real def --
            transversalPosition LanePosition,
            laneType LaneType DEFAULT traffic,
            ...
        }
        LanePosition ::= INTEGER { -- real def --
            offTheRoad          (-1),
            innerHardShoulder   (0),
            outerHardShoulder   (14)
        } (-1..14)
        LaneType::= INTEGER{ -- simplified: only some
            values              --
            traffic             (0),
            pedestrian          (12),
            parking             (17),
            emergency           (18)
            ...
        }(0..31)
        END
    \end{lstlisting}
\end{multicols}

Because ASN.1 is both human-readable and machine-readable, an ASN.1 compiler can compile modules into libraries
of code, codecs, that decode or encode the data structures.

ASN.1 defines different encoding rules that specify how to represent a data structure as bytes. Basic Encoding Rules
(BER) is the oldest one, Packed Encoding Rules (PER) is the most compact. XML Encoding Rule (XER) is based on
XML. JSON encoding rules (JER) is the easiest to start playing with ASN.1 and to debug applications.\\

In this part we will consider two messages, one about “ego”, one about “alter”:

\textbf{Message 1:} “Ego is a Highway Grass Cutting Machine with id AB-123-CD. It uses and stores diesel, liquid propane
gas, and electricity. It drives forward on the outer hard shoulder at a speed of 10.8 km/h.”

\textbf{Message 2:} “Alter EF-456-GH is moving forward at 144 km/h on traffic lane number 3, not respecting safe distances”

Note: Check out the appendices A-E, as they are all important to answer the questions in this part.
%Separador Horizontal
\noindent\rule{\textwidth}{0.4mm} 

\begin{enumerate}[label=\textbf{Question \arabic*.}]
    \item \textbf{(1 pt)} Justify that the encoded value for speed 10.8 km/h is integer 300.\\
    
    \textbf{Answer:} \\
    We have that the speed given is 10.8 km/h. Tranfsorming in m/s we have:\\
    \[ \frac{10.8}{3.6} = 3 \ \text{m/s} \]
    The system represents speed in units of  0.01 m/s , meaning that each integer represents 0.01 m/s. So: 
    \[ 3 \, \text{m/s} = 300 \times 0.01 \, \text{m/s} \]
    Thus, the speed value 10.8 km/h corresponds to the encoded value \textbf{300} in the system.
    
    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm} 
    
    \item \textbf{(2 pts)}
    \begin{itemize}
        \item How IEEE 754 floating point number would encode the value 144.0 ?
    \end{itemize}
        \textbf{Answer:} \\
        We know that $144$ is a integer number and, in binary is represented by:
        \[ 10010000_2 \]
        Thus, representing in $1.bits\times2^{exp}$, we have:
        \[ 10010000_2 = 1.0010000\times2^7 \]
        Thus, the value of the exponent $(e)$ is:
        \begin{align*}
            e &= 7 \\
            7 + 127 &= 134
        \end{align*}
        And, the value of $134_2$ in binary is:
        \[ 1000\ 0110_2 \]
        Now, for the Mantissa, we have the value after the explicit 1. Remember that it should have 23 bits. So:
        \[ 001\ 0000_2 \\\]
        and, with 23 zeros,
        \[ 001\ 0000\ 0000\ 0000\ 0000\ 0000\]
        Since the number is positive, the value of the signal is zero.
        Thus, the fial representation in IEEE 754 is:
        \[ 0\ 10000110\ 00100000000000000000000 \]
        \parbox{\textwidth}{
            \small
            Where: \\
            0: represents the sign bit, \\
            10000110: represents the exponent, \\
            00100000000000000000000: represents the mantissa.
        } \\

        And, in hexadecimal:
        \[ \underbrace{0100}_{4}\ \underbrace{0011}_{3}\ \underbrace{0001}_{1}\ \underbrace{0000}_{0}\ \underbrace{0000}_{0}\ \underbrace{0000}_{0}\ \underbrace{0000}_{0}\ \underbrace{0000}_{0}\ \]
        Resulting in: 0x43100000.\\
        %Separador Horizontal
        \noindent\rule{\textwidth}{0.4mm}

    \begin{itemize}
        \item Find an IEEE 754 floating point number that approximates 10.8 at ±0.05
    \end{itemize}
        \textbf{Answer:} \\
        First of all, since is impossible to convert 10.8, we are going to use a range of $\pm$ 0.5. In this exercise, lets consider our number as 10.75. So, transforming 10.75 in binary: \\
        
        We have that the integer part is 10 and the fractional part is 0.75. The integer part is represented by:
        \[ 10_{10} = 1010_2 \]
        For the fractional part, we have to do the following opperations:
        \[ \text{Multiply}\ 0.75\times2=1.5 \]
        Record 1 for the integer part, and, after:
        \[ \text{Multiply}\ 0.5\times2=1.0 \]
        Record 1 for the integer part, and, since we've achieved the 0, we stop. Therefore, the number 10.75 in binay is:
        \[1010.11\]
        Normalizing the binary, we have:
        \[1.01011\times2^3\]
        Since the number is positive, the value of the sign is 0 and the expoent value is 130, which is:
        \[1000\ 0010_2\]
        The mantissa, is equal to $01011$ with zeros until 23 bits.
        \[010\ 1100\ 0000\ 0000\ 0000\ 0000_2\]
        So, the final IEEE 754 number is equal to:
        \[0\ 10000010\ 01011000000000000000000\]
        \parbox{\textwidth}{
            \small
            Where: \\
            0: represents the sign bit, \\
            10000010: represents the exponent, \\
            01011000000000000000000: represents the mantissa.
        } \\
        And, in hexadecimal:
        \[ \underbrace{0100}_{4}\ \underbrace{0001}_{1}\ \underbrace{0010}_{2}\ \underbrace{1100}_{C}\ \underbrace{0000}_{0}\ \underbrace{0000}_{0}\ \underbrace{0000}_{0}\ \underbrace{0000}_{0}\ \]
        Resulting in: 0x412C0000.\\
        %Separador Horizontal
        \noindent\rule{\textwidth}{0.4mm}

    \break
    \item \textbf{(4 pts)} Write a document that could be a plausible JER encoding of Message 1 about “ego” \\
    
    \textbf{Answer:} 
    \begin{lstlisting}
        {
            "EgoData": {
              "id": "AB-123-CD",
              "energyStorage": "10110",  // diesel(4), liquidPropaneGas(2), electricEnergyStorage(1) -> BIT STRING
              "speed": 1080,  // 10.8 km/h is 3 m/s -> 3 m/s = 300 * 0.01 m/s -> SpeedValue = 300
              "driveDirection": 0,  // 0 = forward
              "lanePosition": {
                "simplelanePosition": 14  // outerHardShoulder
              }
            }
          }
        \end{lstlisting}
        %Separador Horizontal
        \noindent\rule{\textwidth}{0.4mm}
    
    \item \textbf{(1 pt)} BER-encode the BIT STRING. \texttt{diesel+liquidPropaneGas+electricEnergyStorage}
    
    \textbf{Answer:} \\
    For the purpose of encoding, we need to first define each feature (like diesel, liquidPropaneGas, and electricEnergyStorage) as individual bits within the bit string. Let’s assign them specific bit positions:

    \begin{enumerate}
        \item \texttt{diesel}: bit 1
        \item \texttt{liquidPropaneGas}: bit 2
        \item \texttt{electricEnergyStorage}: bit 3
    \end{enumerate}
    Thus, the bit string to represent "\texttt{diesel+liquidPropaneGas+electricEnergyStorage}" would have the first three bits set to 1. The bit string is: 
    \[1110\ 0000_2\]
    We know that, in the BET pattern, the TAG for Bit String is "\texttt{03}".
    For the length of the data, we have 1 byte for the non used bits and 1 byte for the used bits. So, the total length is 2 bytes.\\
    The non used bits, represented by the value $05$.
    For the value of the Bit String, the binary sequence that represents the three active bits is:
    \[1110\ 0000_2\]
    Which value, in hexadecimal is:
    \[E0_{16}\]
    Then, the codification is:
    \[03\ 02\ 01\ 68\]
    \parbox{\textwidth}{
        \small
        Where: \\
        03: represents the TAG, \\
        02: represents the length of data, \\
        05: represents the non utilized bits. \\
        E0: represents the codified value of the BIT STRING
    } \\

    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm}
    The XML document below is the XER encoding of Message 2 about “alter”: \\
    \lstset{
        language=XML, % Define o tipo de linguagem como XML
        frame=single, % Moldura ao redor do código
        numbers=left, % Numeração das linhas à esquerda
        numberstyle=\tiny, % Tamanho da fonte para os números
        basicstyle=\ttfamily\small, % Fonte monoespaçada
        keywordstyle=\color{blue}, % Cor das tags XML
        stringstyle=\color{red}, % Cor para as strings
        breaklines=true, % Quebra de linha automática
        showstringspaces=false % Não mostrar espaços
    }

    \begin{lstlisting}
        <?xml version="1.0" encoding="UTF-8"?>
        <AlterData>
            <id>EF-456-GH</id>
            <safeDistance>
                <false />
            </safeDistance>
            <speed>4000<speed>
            <driveDirection>
                <forward />
            </driveDirection>
            <lanePosition>
                <detailedlanePosition>
                    <transversalPosition>3</transversalPotion>
                    <laneType>traffic</laneType>
                </detailedlanePosition>
            </lanePosition>
        </AlterData>
    \end{lstlisting}
    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm}
    
    \item \textbf{(1 pt)} I injected two syntax errors in this document. For each error, give the line number and explain it. \\

    \textbf{Answer:} \\
    The syntax errors are: \\

    Line 07:
    \[\texttt{<speed>4000\hl{<speed>}}\]
    And the corrected version:
    \[\texttt{<speed>4000</speed>}\]
    Line 12:
    \[\texttt{<transversalPosition>3\hl{</transversalPotion>}}\]
    And the corrected version:
    \[\texttt{<transversalPosition>3</transversalPosition>}\]

    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm}

    \item \textbf{(1 pt)} What would be the BER encoding of (a) positive integer 4000 ? (b) negative integer -120 ?
    \begin{enumerate}
        \item Positive Integer 4000 \\
        We have that integer values are divided in two parts. The identifier byte, the length and the value. So, for the number 4000, we have:
        \begin{enumerate}[label=\text{-}]
            \item Identifier Byte: $02$
            \item Length Bytes: $02$, once 4000 needs two bytes to be represented
            \item Value Bytes: We have to transform 4000 to hexadecimal,
            \[4000_{10} = 1111\ 1010\ 0000_{2} = FA0_{16}\]
            So, the value, in hexadecimal is 0FA0.
        \end{enumerate}
        Then, the encoded value of integer 4000 is:
        \[\texttt{02\ 02\ 0F\ A0}\]
        \item Negative Integer -120\\
        For the negative values, we have to do the two's complement. So, for the number -120, we have: \\
        \[120_{10} = 0111\ 1000_{2}\]
        With the one's complement:
        \[0111\ 1000_{2} \to 1000\ 0111_{2}\]
        With the two's complement, we sum 1, to the previous value:
        \[1_{2} + 1000\ 0111_{2} = 1000\ 1000_{2}\]
        Which value, in hexadecimal is:
        \[\texttt{0x88}\]
        \begin{enumerate}[label=\text{-}]
            \item Identifier Byte: \texttt{02}
            \item Length Bytes: \texttt{01}, once -120 needs only one byte to be represented
            \item Value Bytes: As we've seen above, the value of -120 in hexadecimal is: \texttt{0x88}
        \end{enumerate}
        Then, the encoded value of -120 is:
        \[\texttt{02\ 01\ 88}\]
    \end{enumerate}
    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm}
    
    \item \textbf{(1 pt)} Justify that the maximal encodable length in BER is \texttt{$2^{1008}$} \\ 

    \textbf{Answer:} \\
    In BER encoding, the maximum encodable length is determined by the long form, where 126 bytes can be used to represent the length. Since each byte has 8 bits, this gives a total of 1008 bits available for encoding the length. The maximum value that can be encoded with 1008 bits is $2^{1008}$, which represents the largest possible encodable length in BER. This system allows for the encoding of extremely large data lengths, making it highly flexible for encoding purposes.
    
    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm}

    \item \textbf{(1 pt)} Assume we want to set the message IA5String in Message 2 about “alter” as follows:
    \begin{center}
        “Warning: Automated grass cutter ahead. Maintain safe distance. Speed reduced. Hazardous debris possible. Stay alert for sudden stops and avoid lane changes near the vehicle. Thank you for your cooperation.”
    \end{center}

    This message has a total of 205 characters. Give the most significant four bytes of that message encoded using BER. \\

    \textbf{Answer:} \\
    We have that the IA5String is a primitive, so, the class identifier is \texttt{$00_{16}$}, \texttt{0} for the P/C bit, and, for the TAG evaluation, we have \texttt{$22_{10}$} which is \texttt{$16_{16}$}. Since the length is too big, we're going to use the Long form.
    In this case, since 205 is less than 256, we need 1 byte to represent the length. The first byte in the length encoding would be 0x81 (indicating 1 additional byte for the length), and the next byte is 0xCD (which is 205 in hexadecimal). \\
    So, the final encoded value is:\\
    \[\texttt{16 81 CD 57}\]
    \parbox{\textwidth}{
        \small
        Where: \\
        16: represents the TAG, \\
        81 CD: represents the length of data, \\
        57: represents the fist letter "W"
    } \\

    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm}

    \item \textbf{(1 pt)} Justify that the identifier octet for a SEQUENCE needs to be $30_{16}$. \\
    
    \textbf{Answer:}

    We have that:
    \begin{itemize}[left=0pt]
        \item \textbf{Class:} \texttt{SEQUENCE} is a universal type, represented by the bits \texttt{00}.
        \item \textbf{Constructed Type:} \texttt{SEQUENCE} contains other types within it, so it’s marked as constructed with the bit \texttt{1}.
        \item \textbf{Tag Number:} The ASN.1 tag for \texttt{SEQUENCE} is 16 in decimal, which is \texttt{10000} in binary.
    \end{itemize}
    
    Combining these parts (universal \texttt{00}, constructed \texttt{1}, tag \texttt{10000}) results in the binary \texttt{0011\ 0000}, which converts to 30 in hexadecimal.
    
    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm}

    \item \textbf{(4 pts)} Determine the BER-encoding for Message 2 about “alter”. Justify step by step.\\

    \textbf{Answer:}

    \begin{table}[H] % O modificador [H] força a tabela a aparecer exatamente onde está definida
        \centering
        \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Element} & \textbf{Type} & \textbf{Length} & \textbf{Content} \\
        \hline
        \texttt{Sequence} & \texttt{30}$_{16}$ & ?? & -- \\
        \hline
        \textbf{id} & -- & -- & -- \\
        \hline
        \texttt{IA5String} & \texttt{16}$_{16}$ & \texttt{09}$_{16}$ & ``EF-456-GH'' \\
        \hline
        \textbf{safeDistance} & -- & -- & -- \\
        \hline
        \texttt{Boolean} & \texttt{01}$_{16}$ & \texttt{01}$_{16}$ & \texttt{00}$_{16}$ \\
        \hline
        \textbf{speed} & -- & -- & -- \\
        \hline
        \texttt{Integer} & \texttt{02}$_{16}$ & \texttt{02}$_{16}$ & \texttt{0F A0}$_{16}$ \\
        \hline
        \textbf{driveDirection} & (Enumerated) & -- & -- \\
        \hline
        \texttt{Enumerated} & \texttt{0A}$_{16}$ & \texttt{01}$_{16}$ & \texttt{01}$_{16}$ \\
        \hline
        \textbf{lanePosition} & (CHOICE: \textit{simpleLanePosition} as INTEGER) & -- & -- \\
        \hline
        \texttt{INTEGER} & \texttt{02}$_{16}$ & \texttt{01}$_{16}$ & \texttt{03}$_{16}$ \\
        \hline
        \end{tabular}
    \end{table}

    So, the content of \texttt{SEQUENCE} is 24 bytes, and, the length of octet is \texttt{$18_{16}$}.
    
    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm}

    \item \textbf{(1 pt)} What can go wrong with id and message being both OPTIONAL in the definition of AlterData ?
    Suggest additional encoding rules involving bits 8 and 7 of the identifier octet to avoid this issue. \\

    \textbf{Answer:}
    
    When both id and message fields are marked as OPTIONAL in the AlterData sequence, there’s a risk that neither is provided. If neither id nor message is present in the data, it may lead to ambiguity or incomplete data, as there would be no unique identifier or descriptive message to specify the instance of AlterData.
    
    To address this, you could introduce encoding rules using bits 8 and 7 of the identifier octet:

    \begin{enumerate}[label=\text{-}]
        \item \textbf{Bit 8 as Presence Indicator for \texttt{id}:} When bit 8 is set to 1, it indicates that the \texttt{id} field is present. If bit 8 is 0, \texttt{id} is absent.
        \item \textbf{Bit 7 as Presence Indicator for \texttt{message}:} Similarly, bit 7 can be set to 1 to indicate that \texttt{message} is present, or 0 if \texttt{message} is absent.
    \end{enumerate}

    %Separador Horizontal
    \noindent\rule{\textwidth}{0.4mm}

    \item \textbf{(2 pts)} The most compact ASN.1 encoding rules are the Packed Encoding Rules (PER). This is the one
    commonly used in 3GPP cellular technologies such as UMTS (3G), LTE (4G), or 5G.
    Give (4 maximum) concrete ideas for how PER greatly improves compaction with respect to BER. \\

    \textbf{Answer:}
    \begin{enumerate}
        \item \textbf{Elimination of Length Fields for Fixed-Length Data:} In PER, fields with a fixed length don’t include a length indicator, reducing the encoded size. BER, however, includes length fields for every element, even if the length is already predetermined, adding unnecessary bytes.
        
        \item \textbf{Removal of Tags for Ordered Sequences:} PER omits tags in cases where the field type and order are known in advance. In contrast, BER encodes a tag for every field, increasing the size of the encoding.
        
        \item \textbf{Optimized Integer Encoding:} PER encodes integers using only the minimum number of bits required by their range, rather than fixed-width encodings. For instance, if an integer is defined within a range of 0 to 255, PER uses just 1 byte, compared to the standard integer sizes used in BER.
        
        \item \textbf{Efficient Handling of Optional and Default Fields:} PER compacts optional fields into a single bit in a bit-field to denote their presence or absence and skips encoding fields set to default values entirely. BER, in contrast, encodes each field and includes optional values even when they’re not used, leading to a larger overall size.
    \end{enumerate}

        
\end{enumerate}


    



\end{document}